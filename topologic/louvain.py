# Copyright (c) Microsoft Corporation.
# Licensed under the MIT license.

# See also: https://github.com/taynaud/python-louvain

import networkx as nx
import community
from typing import Any, Dict, NamedTuple, Optional, Union
import logging
import numpy as np
import warnings


def best_partition(
        graph: nx.Graph,
        partition: Optional[Dict[Any, int]] = None,
        weight_attribute: str = 'weight',
        resolution: float = 1.,
        random_state: Any = None
) -> Dict[Any, int]:
    """
    Compute the partition of the graph nodes which maximises the modularity (or try..) using the Louvain heuristics

    This is the partition of highest modularity, i.e. the highest partition of the dendrogram generated by the Louvain
    algorithm.

    :param networkx.Graph graph: the networkx graph which is decomposed
    :param partition: the algorithm will start using this partition of the nodes. It's a
        dictionary where keys are their nodes and values the communities
    :type partition: Optional[Dict[Any, int]]
    :param str weight_attribute: the key in graph to use as weight. Default to 'weight'
    :param float resolution: Will change the size of the communities, default to 1. represents the time described in
        "Laplacian Dynamics and Multiscale Modular Structure in Networks", R. Lambiotte, J.-C. Delvenne, M. Barahona
    :param Any random_state: If int, random_state is the seed used by the random number generator;
        If RandomState instance, random_state is the random number generator;
        If None, the random number generator is the RandomState instance used
        by `np.random`.
    :return: The partition, with communities numbered from 0 to number of communities
    :rtype: Dict[Any, int]
    :raises: NetworkXError - If the graph is not Eulerian.

    References
    1. Blondel, V.D. et al. Fast unfolding of communities in large networks. J. Stat. Mech 10008, 1-12(2008).
    """

    return community.best_partition(
        graph=graph,
        partition=partition,
        weight=weight_attribute,
        resolution=resolution,
        random_state=random_state
    )


class InducedCommunityGraph(NamedTuple):
    """
    Container for the induced community graph and the communities dictionary that links this
    induced graph back to the original graph
    """
    graph: nx.Graph
    communities: Dict[Any, int]


def induced_community_graph(
        graph: nx.Graph,
        weight_attribute: str = 'weight',
        resolution: float = 1.0,
        random_state: Optional[Union[int, np.random.RandomState]] = None
) -> InducedCommunityGraph:
    """
    Identifies the community structure of a graph by using the Louvain algorithm, generating
    a dictionary of original vertex to community id relationships.

    Using this dictionary, it then induces a community graph based on the original graph's
    edge connections and aggregating the weights.

    The result of both communities and the induced graph is wrapped in an InducedCommunityGraph
    container NamedTuple.

    :param networkx.Graph graph: The original graph to calculate community structure for and induce a graph from.
    :param str weight_attribute: The weight attribute on the original graph's edges; this is
        both used to determine the best community structure in louvain as well as aggregated
        into the final edge weight in the community structure.  Default is `weight`.
    :param float resolution: Will change the size of the communities, default to 1. represents the time described in
        "Laplacian Dynamics and Multiscale Modular Structure in Networks", R. Lambiotte, J.-C. Delvenne, M. Barahona
    :param random_state: If int, random_state is the seed used by the
        random number generator;
        If RandomState instance, random_state is the random number generator;
        If None, the random number generator is the RandomState instance used by `np.random`.
    :type random_state: Union[int, numpy.random.RandomState]
    :return: The induced community graph and the original graph's vertex->community mapping
        in a Dictionary.
    :rtype: InducedCommunityGraph
    :raises ValueError: If the graph is None
    """
    communities = best_partition(
        graph=graph,
        partition=None,
        weight_attribute=weight_attribute,
        resolution=resolution,
        random_state=random_state
    )
    induced = induce_graph_by_communities(
        graph=graph,
        communities=communities,
        weight_attribute=weight_attribute
    )
    return InducedCommunityGraph(graph=induced, communities=communities)


def induce_graph_by_communities(
        graph: nx.Graph,
        communities: Dict[Any, int],
        weight_attribute: str = 'weight'
) -> nx.Graph:
    """
    Creates a community graph with nodes from the communities dictionary
    and using the edges of the original graph to form edges between communities.

    Weights are aggregated; you may need to normalize the resulting graph
    after calling this function.

    Note: logs a warning if the size of the community dictionary is less than
    the size of the provided graph's vertexset.

    :param networkx.Graph graph: The original graph that contains the edges that will be
        used to formulate a new induced community graph
    :param communities: The communities dictionary provides a mapping of
        original vertex ID to new community ID.
    :type communities: dict[Any, int]
    :param str weight_attribute: The weight attribute on the original graph's edges to use
        when aggregating the weights of the induced community graph.  Default is `weight`.
    :return: The induced community graph.
    :rtype: networkx.Graph
    :raises ValueError: If the graph is None
    :raises ValueError: If the communities dictionary is None
    """
    logger = logging.getLogger(__name__)
    if graph is None:
        raise ValueError("graph cannot be None")
    if communities is None:
        raise ValueError("communities cannot be None")
    if len(communities) < len(graph.nodes()):
        logger.warning(
            f"Length of communities provided ({len(communities)}) is less than the " +
            f"total number of nodes in the graph ({len(graph.nodes())})"
        )

    return community.induced_graph(
        communities,
        graph,
        weight_attribute
    )


def induced_graph_for_best_partition(
        graph: nx.Graph,
        partition: Optional[Dict[Any, int]] = None,
        weight_attribute: str = 'weight',
        resolution: float = 1.0,
        random_state: Any = None
) -> nx.Graph:
    warnings.warn(
        "induced_graph_for_best_partition() is deprecated; " +
        "use either induced_community_graph or induce_graph_by_communities.",
        DeprecationWarning
    )
    """
    DEPRECATED: See :py:func:: `induce_graph_by_communities` or :py:func:: `induced_community_graph`
    for replacements

    Return an induced graph for the best Louvain partition of the input graph. The induced
    graph consists of one node per community in the best partition.

    :param networkx.Graph graph: the networkx graph
    :param partition: a Dict of node to community representing the starting partition
    :type partition: Optional[Dict[Any, int]]
    :param str weight_attribute: the name of the edge weight attribute
    :param float resolution: Will change the size of the communities, default to 1.
        represents the time described in
        "Laplacian Dynamics and Multiscale Modular Structure in Networks",
        R. Lambiotte, J.-C. Delvenne, M. Barahona
    :param random_state: If int, random_state is the seed used by the random number
        generator; If RandomState instance, random_state is the random number generator;
        If None, the random number generator is the RandomState instance used
        by `np.random`.
    :type random_state: Optional[Union[int, numpy.random.RandomState]]
    :return: an induced graph of the communities in the best partition of the input graph
    :rtype: networkx.Graph
    """
    if partition is None:
        partition = best_partition(graph, partition, weight_attribute, resolution, random_state)
    return community.induced_graph(partition, graph, weight_attribute)
